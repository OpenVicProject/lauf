module @memory;

function @poison_unpoison_memory() {
    layout $lauf.Value; $lauf.heap.alloc;

    uint 42; pick 1; store_field $lauf.Value 0;
    pick 0; $lauf.memory.poison;

    pick 0; $lauf.memory.unpoison;
    pick 0; load_field $lauf.Value 0; uint 42; $lauf.test.assert_eq;

    $lauf.heap.free;
    return;
}
function @double_poison() {
    layout $lauf.Value; $lauf.heap.alloc;

    pick 0; $lauf.memory.poison;
    pick 0; $lauf.memory.poison;

    $lauf.heap.free;
    return;
}
function @unpoison_non_poisoned() {
    layout $lauf.Value; $lauf.heap.alloc;
    pick 0; $lauf.memory.unpoison;

    $lauf.heap.free;
    return;
}
function @access_poison() {
    layout $lauf.Value; $lauf.heap.alloc;

    pick 0; $lauf.memory.poison;
    uint 42; pick 1; store_field $lauf.Value 0;

    $lauf.heap.free;
    return;
}

function @split_unsplit() {
    layout $lauf.Value; uint 2; $lauf.heap.alloc_array; pick 0;

    uint 1; array_element $lauf.Value; $lauf.memory.split;
    # original_ptr addr1 addr2
    uint 42; pick 2; store_field $lauf.Value 0;
    uint 11; pick 1; store_field $lauf.Value 0;

    # original_ptr addr1 addr2
    $lauf.memory.merge;
    # original_ptr split_ptr
    pick 1; $lauf.test.assert_eq;

    # original_ptr
    pick 0; uint 0; array_element $lauf.Value; load_field $lauf.Value 0; uint 42; $lauf.test.assert_eq;
    pick 0; uint 1; array_element $lauf.Value; load_field $lauf.Value 0; uint 11; $lauf.test.assert_eq;

    $lauf.heap.free;
    return;
}
function @split4() {
    layout $lauf.Value; uint 4; $lauf.heap.alloc_array;

    uint 2; array_element $lauf.Value; $lauf.memory.split;
    # addr1 addr2
    roll 1; uint 1; array_element $lauf.Value; $lauf.memory.split;
    # addr2 addr11 addr12
    roll 2; uint 1; array_element $lauf.Value; $lauf.memory.split;
    # addr11 addr12 addr21 addr22

    $lauf.memory.merge;
    # addr11 addr12 addr2
    roll 2; roll 2; $lauf.memory.merge;
    # addr2 addr1
    roll 1; $lauf.memory.merge;

    # addr
    $lauf.heap.free;
    return;
}
function @split_local() {
    local %array : [2]$lauf.Value;

    local_addr %array; uint 1; array_element $lauf.Value; $lauf.memory.split;
    # addr1 addr2
    uint 42; pick 2; store_field $lauf.Value 0;
    uint 11; pick 1; store_field $lauf.Value 0;
    # addr1 addr2
    $lauf.memory.merge; pop 0;

    local_addr %array; uint 0; array_element $lauf.Value; load_field $lauf.Value 0; uint 42; $lauf.test.assert_eq;
    local_addr %array; uint 1; array_element $lauf.Value; load_field $lauf.Value 0; uint 11; $lauf.test.assert_eq;

    return;
}

function @split_overflow() {
    layout $lauf.Value; uint 2; $lauf.heap.alloc_array;

    uint 1; array_element $lauf.Value; $lauf.memory.split;
    # addr1 addr2
    uint 42; pick 2; uint 0; array_element $lauf.Value; store_field $lauf.Value 0;
    uint 11; pick 2; uint 1; array_element $lauf.Value; store_field $lauf.Value 0;

    # addr1 addr2
    $lauf.memory.merge;
    $lauf.heap.free;
    return;
}
function @split_heap_free() {
    layout $lauf.Value; uint 2; $lauf.heap.alloc_array;

    pick 0; uint 1; array_element $lauf.Value; $lauf.memory.split; pop 0; pop 0;

    $lauf.heap.free;
    return;
}
function @split_local_free() {
    local %array : [2]$lauf.Value;

    local_addr %array; uint 1; array_element $lauf.Value; $lauf.memory.split; pop 0; pop 0;
    return;
}

global const @msg_invalid_address = "invalid address", 0;
global const @msg_invalid_heap_address = "invalid heap address", 0;
global const @msg_invalid_free = "cannot free split allocation", 0;

function @main() {
    call @poison_unpoison_memory;
    function_addr @double_poison; global_addr @msg_invalid_address; $lauf.test.assert_panic;
    function_addr @unpoison_non_poisoned; global_addr @msg_invalid_address; $lauf.test.assert_panic;
    function_addr @access_poison; global_addr @msg_invalid_address; $lauf.test.assert_panic;

    call @split_unsplit;
    call @split4;
    call @split_local;
    function_addr @split_overflow; global_addr @msg_invalid_address; $lauf.test.assert_panic;
    function_addr @split_heap_free; global_addr @msg_invalid_heap_address; $lauf.test.assert_panic;
    function_addr @split_local_free; global_addr @msg_invalid_free; $lauf.test.assert_panic;

    return;
}

