module @heap;

function @heap_alloc() {
    layout $lauf.Value; $lauf.heap.alloc;

    uint 42; pick 1; store_field $lauf.Value 0;
    pick 0; load_field $lauf.Value 0; uint 42; $lauf.test.assert_eq;

    $lauf.heap.free;
    return;
}

function @heap_alloc_array() {
    layout $lauf.Value; uint 2; $lauf.heap.alloc_array;

    uint 42; [ pick 1; uint 0; array_element $lauf.Value; ] store_field $lauf.Value 0;
    uint 11; [ pick 1; uint 1; array_element $lauf.Value; ] store_field $lauf.Value 0;

    [ pick 0; uint 0; array_element $lauf.Value; ] load_field $lauf.Value 0; uint 42; $lauf.test.assert_eq;
    [ pick 0; uint 1; array_element $lauf.Value; ] load_field $lauf.Value 0; uint 11; $lauf.test.assert_eq;

    $lauf.heap.free;
    return;
}

function @heap_transfer_local() {
    local %foo : $lauf.Value;
    uint 42; local_addr %foo; store_field $lauf.Value 0;

    local_addr %foo; $lauf.heap.transfer_local;
    pick 0; load_field $lauf.Value 0; uint 42; $lauf.test.assert_eq;

    pop 0; #$lauf.heap.free;
    return;
}
function @heap_transfer_local_from_heap() {
    layout $lauf.Value; $lauf.heap.alloc; pick 0;
    pick 0; $lauf.heap.transfer_local; $lauf.test.assert_eq;
    $lauf.heap.free;
    return;
}

function @heap_double_free() {
    layout $lauf.Value; $lauf.heap.alloc;

    pick 0; $lauf.heap.free;
    $lauf.heap.free;
    return;
}
function @heap_free_local() {
    local %foo : $lauf.Value;
    local_addr %foo; $lauf.heap.free;
    return;
}
function @heap_use_after_free() {
    layout $lauf.Value; $lauf.heap.alloc;
    pick 0; $lauf.heap.free;
    uint 42; store_field $lauf.Value 0;
    return;
}

function @poison_unpoison_memory() {
    layout $lauf.Value; $lauf.heap.alloc;

    uint 42; pick 1; store_field $lauf.Value 0;
    pick 0; $lauf.heap.poison;

    pick 0; $lauf.heap.unpoison;
    pick 0; load_field $lauf.Value 0; uint 42; $lauf.test.assert_eq;

    $lauf.heap.free;
    return;
}
function @double_poison() {
    layout $lauf.Value; $lauf.heap.alloc;

    pick 0; $lauf.heap.poison;
    pick 0; $lauf.heap.poison;

    $lauf.heap.free;
    return;
}
function @unpoison_non_poisoned() {
    layout $lauf.Value; $lauf.heap.alloc;
    pick 0; $lauf.heap.unpoison;

    $lauf.heap.free;
    return;
}
function @access_poison() {
    layout $lauf.Value; $lauf.heap.alloc;

    pick 0; $lauf.heap.poison;
    uint 42; pick 1; store_field $lauf.Value 0;

    $lauf.heap.free;
    return;
}

global const @msg_invalid_address = "invalid address", 0;
global const @msg_invalid_heap_address = "invalid heap address", 0;

function @main() {
    call @heap_alloc;
    call @heap_transfer_local;
    call @heap_transfer_local_from_heap;

    function_addr @heap_double_free; global_addr @msg_invalid_heap_address; $lauf.test.assert_panic;
    function_addr @heap_free_local; global_addr @msg_invalid_heap_address; $lauf.test.assert_panic;
    function_addr @heap_use_after_free; global_addr @msg_invalid_address; $lauf.test.assert_panic;

    call @poison_unpoison_memory;
    function_addr @double_poison; global_addr @msg_invalid_heap_address; $lauf.test.assert_panic;
    function_addr @unpoison_non_poisoned; global_addr @msg_invalid_heap_address; $lauf.test.assert_panic;
    function_addr @access_poison; global_addr @msg_invalid_address; $lauf.test.assert_panic;

    return;
}

